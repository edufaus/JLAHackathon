import type { Box, Getter, ReadableBoxedValues, WithRefProps, WritableBox, WritableBoxedValues } from "svelte-toolbelt";
import type { MouseEventHandler, PointerEventHandler } from "svelte/elements";
import { PositionFixed } from "./position-fixed.svelte.js";
import { SnapPointsState } from "./snap-points.svelte.js";
import type { DrawerDirection, OnDrag, OnRelease } from "./types.js";
type DrawerRootStateProps = ReadableBoxedValues<{
    closeThreshold: number;
    shouldScaleBackground: boolean;
    scrollLockTimeout: number;
    snapPoints: (string | number)[] | undefined;
    fadeFromIndex: number | undefined;
    fixed: boolean;
    dismissible: boolean;
    direction: DrawerDirection;
    onDrag: OnDrag;
    onRelease: OnRelease;
    nested: boolean;
    onClose: () => void;
    backgroundColor: string | undefined;
    modal: boolean;
    handleOnly: boolean;
    noBodyStyles: boolean;
    preventScrollRestoration: boolean;
    setBackgroundColorOnScale: boolean;
    container: HTMLElement | null;
    snapToSequentialPoint: boolean;
    repositionInputs: boolean;
    autoFocus: boolean;
}> & WritableBoxedValues<{
    open: boolean;
    activeSnapPoint: number | string | null | undefined;
}>;
export declare class DrawerRootState {
    open: DrawerRootStateProps["open"];
    activeSnapPoint: DrawerRootStateProps["activeSnapPoint"];
    closeThreshold: DrawerRootStateProps["closeThreshold"];
    shouldScaleBackground: DrawerRootStateProps["shouldScaleBackground"];
    scrollLockTimeout: DrawerRootStateProps["scrollLockTimeout"];
    snapPoints: DrawerRootStateProps["snapPoints"];
    fadeFromIndex: DrawerRootStateProps["fadeFromIndex"];
    fixed: DrawerRootStateProps["fixed"];
    dismissible: DrawerRootStateProps["dismissible"];
    direction: DrawerRootStateProps["direction"];
    onDragProp: DrawerRootStateProps["onDrag"];
    onReleaseProp: DrawerRootStateProps["onRelease"];
    nested: DrawerRootStateProps["nested"];
    onCloseProp: DrawerRootStateProps["onClose"];
    backgroundColor: DrawerRootStateProps["backgroundColor"];
    modal: DrawerRootStateProps["modal"];
    handleOnly: DrawerRootStateProps["handleOnly"];
    noBodyStyles: DrawerRootStateProps["noBodyStyles"];
    preventScrollRestoration: DrawerRootStateProps["preventScrollRestoration"];
    setBackgroundColorOnScale: DrawerRootStateProps["setBackgroundColorOnScale"];
    container: DrawerRootStateProps["container"];
    snapToSequentialPoint: DrawerRootStateProps["snapToSequentialPoint"];
    repositionInputs: DrawerRootStateProps["repositionInputs"];
    autoFocus: DrawerRootStateProps["autoFocus"];
    hasBeenOpened: boolean;
    isDragging: boolean;
    justReleased: boolean;
    overlayNode: HTMLElement | null;
    openTime: Date | null;
    dragStartTime: Date | null;
    dragEndTime: Date | null;
    lastTimeDragPrevented: Date | null;
    isAllowedToDrag: boolean;
    nestedOpenChangeTimer: number | null;
    pointerStart: number;
    keyboardIsOpen: boolean;
    previousDiffFromInitial: number;
    drawerNode: HTMLElement | null;
    drawerHeight: number;
    drawerWidth: number;
    initialDrawerHeight: number;
    snapPointsState: SnapPointsState;
    snapPointsOffset: number[];
    positionFixedState: PositionFixed;
    constructor(props: DrawerRootStateProps);
    setActiveSnapPoint: (snapPoint: string | number | null) => void;
    onSnapPointChange: (activeSnapPointIndex: number) => void;
    onPress: (e: PointerEvent) => void;
    shouldDrag: (el: EventTarget | null, isDraggingInDirection: boolean) => boolean;
    onDrag: (e: PointerEvent) => void;
    closeDrawer: (fromWithin?: boolean) => void;
    resetDrawer: () => void;
    cancelDrag: () => void;
    onRelease: (e: PointerEvent | MouseEvent) => void;
    onNestedOpenChange: (o: boolean) => void;
    onNestedDrag: (_e: PointerEvent | MouseEvent, percentageDragged: number) => void;
    onNestedRelease: (_e: PointerEvent | MouseEvent, o: boolean) => void;
    onDialogOpenChange: (o: boolean) => void;
}
type DrawerOverlayStateProps = WithRefProps;
declare class DrawerOverlayState {
    #private;
    mounted: boolean;
    constructor(props: DrawerOverlayStateProps, root: DrawerRootState);
    props: {
        readonly id: string;
        readonly "data-vaul-overlay": "";
        readonly "data-vaul-snap-points": "true" | "false";
        readonly "data-vaul-snap-points-overlay": "true" | "false";
        readonly onmouseup: (e: MouseEvent) => void;
    };
}
type DrawerContentStateProps = WithRefProps & ReadableBoxedValues<{
    onInteractOutside: (e: PointerEvent) => void;
    onPointerDown: PointerEventHandler<HTMLDivElement>;
    onPointerMove: PointerEventHandler<HTMLDivElement>;
    onPointerUp: PointerEventHandler<HTMLDivElement>;
    onPointerOut: PointerEventHandler<HTMLDivElement>;
    onContextMenu: MouseEventHandler<HTMLDivElement>;
    onOpenAutoFocus: (e: Event) => void;
}>;
declare class DrawerContentState {
    #private;
    delayedSnapPoints: boolean;
    pointerStart: {
        x: number;
        y: number;
    } | null;
    lastKnownPointerEvent: PointerEvent | null;
    wasBeyondThePoint: boolean;
    hasSnapPoints: boolean | undefined;
    mounted: boolean;
    constructor(props: DrawerContentStateProps, root: DrawerRootState);
    isDeltaInDirection: (delta: {
        x: number;
        y: number;
    }, direction: DrawerDirection, threshold?: number) => boolean;
    handleOnPointerUp: (e: PointerEvent) => void;
    onOpenAutoFocus: (e: Event) => void;
    onInteractOutside: (e: PointerEvent) => void;
    onFocusOutside: (e: Event) => void;
    snapPointsOffset: number[];
    props: {
        readonly id: string;
        readonly "data-vaul-drawer-direction": DrawerDirection;
        readonly "data-vaul-drawer": "";
        readonly "data-vaul-delayed-snap-points": "true" | "false";
        readonly "data-vaul-custom-container": "true" | "false";
        readonly "data-vaul-snap-points": "true" | "false";
        readonly style: {
            "--snap-point-height": string;
        } | undefined;
        readonly onpointerdown: PointerEventHandler<HTMLDivElement>;
        readonly onpointermove: PointerEventHandler<HTMLDivElement>;
        readonly onpointerup: PointerEventHandler<HTMLDivElement>;
        readonly onpointerout: PointerEventHandler<HTMLDivElement>;
        readonly oncontextmenu: MouseEventHandler<HTMLDivElement>;
    };
}
type DrawerHandleStateProps = WithRefProps & ReadableBoxedValues<{
    preventCycle: boolean;
}>;
declare class DrawerHandleState {
    #private;
    preventCycle: DrawerHandleStateProps["preventCycle"];
    closeTimeoutId: number | null;
    shouldCancelInteraction: boolean;
    constructor(props: DrawerHandleStateProps, root: DrawerRootState);
    handleStartCycle: () => void;
    handleCycleSnapPoints: () => void;
    handleStartInteraction: () => void;
    handleCancelInteraction: () => void;
    props: {
        readonly id: string;
        readonly onclick: () => void;
        readonly onpointerdown: (e: PointerEvent) => void;
        readonly onpointercancel: () => void;
        readonly "data-vaul-drawer-visible": "true" | "false";
        readonly "data-vaul-handle": "";
        readonly "aria-hidden": "true";
    };
    hitAreaProps: {
        readonly "data-vaul-handle-hitarea": "";
        readonly "aria-hidden": "true";
    };
}
declare class DrawerPortalState {
    #private;
    constructor(root: DrawerRootState);
    props: {
        to: HTMLElement | undefined;
    };
}
export declare const setDrawerRootContext: (value: DrawerRootState) => DrawerRootState, getDrawerRootContext: <T extends DrawerRootState | null | undefined = DrawerRootState>(fallback?: T | undefined) => T extends null ? DrawerRootState | null : DrawerRootState;
export declare function useDrawerRoot(props: DrawerRootStateProps): DrawerRootState;
export declare function useDrawerContent(props: DrawerContentStateProps): DrawerContentState;
export declare function useDrawerOverlay(props: DrawerOverlayStateProps): DrawerOverlayState;
export declare function useDrawerHandle(props: DrawerHandleStateProps): DrawerHandleState;
export declare function useDrawerPortal(): DrawerPortalState;
export declare function dampenValue(v: number): number;
type UseRefByIdProps = {
    /**
     * The ID of the node to find.
     */
    id: Box<string>;
    /**
     * The ref to set the node to.
     */
    ref: WritableBox<HTMLElement | null>;
    /**
     * A reactive condition that will cause the node to be set.
     */
    deps?: Getter<unknown>;
    /**
     * A callback fired when the ref changes.
     */
    onRefChange?: (node: HTMLElement | null) => void;
};
/**
 * Finds the node with that ID and sets it to the boxed node.
 * Reactive using `$effect` to ensure when the ID or condition changes,
 * an update is triggered and new node is found.
 */
export declare function useRefById({ id, ref, deps, onRefChange, }: UseRefByIdProps): void;
export {};
