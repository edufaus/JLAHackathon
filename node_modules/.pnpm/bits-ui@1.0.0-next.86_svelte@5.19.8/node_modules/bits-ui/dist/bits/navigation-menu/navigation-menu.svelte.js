import { untrack } from "svelte";
import { afterTick, box, useRefById } from "svelte-toolbelt";
import { Context, Previous } from "runed";
import { getTabbableCandidates } from "../../internal/focus.js";
import { getAriaExpanded, getAriaHidden, getDataDisabled, getDataOpenClosed, getDataOrientation, getDisabled, } from "../../internal/attrs.js";
import { useId } from "../../internal/use-id.js";
import { kbd } from "../../internal/kbd.js";
import { useArrowNavigation } from "../../internal/use-arrow-navigation.js";
import { boxAutoReset } from "../../internal/box-auto-reset.svelte.js";
import { noop } from "../../internal/noop.js";
import { useRovingFocus } from "../../internal/use-roving-focus.svelte.js";
const NavigationMenuRootContext = new Context("NavigationMenu.Root");
const NavigationMenuMenuContext = new Context("NavigationMenu.Root | NavigationMenu.Sub");
const NavigationMenuListContext = new Context("NavigationMenu.List");
const NavigationMenuItemContext = new Context("NavigationMenu.Item");
const NavigationMenuContentContext = new Context("NavigationMenu.Content");
const NAVIGATION_MENU_ROOT_ATTR = "data-navigation-menu-root";
const NAVIGATION_MENU_SUB_ATTR = "data-navigation-menu-sub";
const NAVIGATION_MENU_ITEM_ATTR = "data-navigation-menu-item";
const NAVIGATION_MENU_INDICATOR_ATTR = "data-navigation-menu-indicator";
const NAVIGATION_MENU_LIST_ATTR = "data-navigation-menu-list";
const NAVIGATION_MENU_TRIGGER_ATTR = "data-navigation-menu-trigger";
const NAVIGATION_MENU_CONTENT_ATTR = "data-navigation-menu-content";
const NAVIGATION_MENU_LINK_ATTR = "data-navigation-menu-link";
class NavigationMenuRootState {
    id;
    rootRef;
    delayDuration;
    skipDelayDuration;
    orientation;
    dir;
    value;
    previousValue = new Previous(() => this.value.current);
    openTimer = 0;
    closeTimer = 0;
    skipDelayTimer = 0;
    isOpenDelayed = $state(false);
    #setValue(v) {
        this.value.current = v;
    }
    constructor(props) {
        this.id = props.id;
        this.delayDuration = props.delayDuration;
        this.skipDelayDuration = props.skipDelayDuration;
        this.orientation = props.orientation;
        this.dir = props.dir;
        this.value = props.value;
        this.rootRef = props.ref;
        this.onTriggerEnter = this.onTriggerEnter.bind(this);
        this.onTriggerLeave = this.onTriggerLeave.bind(this);
        this.onContentEnter = this.onContentEnter.bind(this);
        this.onContentLeave = this.onContentLeave.bind(this);
        this.onItemSelect = this.onItemSelect.bind(this);
        this.onItemDismiss = this.onItemDismiss.bind(this);
        useRefById({
            id: this.id,
            ref: this.rootRef,
        });
        $effect(() => {
            this.value.current;
            untrack(() => {
                const curr = this.value.current;
                const isOpen = curr !== "";
                const hasSkipDelayDuration = this.skipDelayDuration.current > 0;
                if (isOpen) {
                    window.clearTimeout(this.skipDelayTimer);
                    if (hasSkipDelayDuration)
                        this.isOpenDelayed = false;
                }
                else {
                    window.clearTimeout(this.skipDelayTimer);
                    this.skipDelayTimer = window.setTimeout(() => (this.isOpenDelayed = true), this.skipDelayDuration.current);
                }
            });
        });
        $effect(() => {
            return () => {
                window.clearTimeout(this.openTimer);
                window.clearTimeout(this.closeTimer);
                window.clearTimeout(this.skipDelayTimer);
            };
        });
    }
    #startCloseTimer() {
        window.clearTimeout(this.closeTimer);
        this.closeTimer = window.setTimeout(() => this.#setValue(""), 150);
    }
    #handleOpen(itemValue) {
        window.clearTimeout(this.closeTimer);
        this.#setValue(itemValue);
    }
    handleClose() {
        this.onItemDismiss();
        this.onContentLeave();
    }
    #handleDelayedOpen(itemValue) {
        const isOpenItem = this.value.current === itemValue;
        if (isOpenItem) {
            // If the item is already open (e.g. we're transitioning from the content to the trigger)
            // then we want to clear the close timer immediately.
            window.clearTimeout(this.closeTimer);
        }
        else {
            this.openTimer = window.setTimeout(() => {
                window.clearTimeout(this.closeTimer);
                this.#setValue(itemValue);
            }, this.delayDuration.current);
        }
    }
    onTriggerEnter(itemValue) {
        window.clearTimeout(this.openTimer);
        if (this.isOpenDelayed) {
            this.#handleDelayedOpen(itemValue);
        }
        else {
            this.#handleOpen(itemValue);
        }
    }
    onTriggerLeave() {
        window.clearTimeout(this.openTimer);
        this.#startCloseTimer();
    }
    onContentEnter() {
        window.clearTimeout(this.closeTimer);
    }
    onContentLeave() {
        this.#startCloseTimer();
    }
    onItemSelect(itemValue) {
        const prevValue = this.value.current;
        this.#setValue(prevValue === itemValue ? "" : itemValue);
    }
    onItemDismiss() {
        this.#setValue("");
    }
    props = $derived.by(() => ({
        id: this.id.current,
        "aria-label": "Main",
        "data-orientation": getDataOrientation(this.orientation.current),
        dir: this.dir.current,
        [NAVIGATION_MENU_ROOT_ATTR]: "",
    }));
}
class NavigationMenuMenuState {
    isRoot = $state(false);
    rootNavigationId;
    dir;
    orientation;
    value;
    previousValue;
    onTriggerEnter;
    onTriggerLeave;
    onContentEnter;
    onContentLeave;
    onItemSelect;
    onItemDismiss;
    viewportNode = $state(null);
    indicatorTrackNode = $state(null);
    viewportContentId = box.with(() => undefined);
    root;
    triggerRefs = new Set();
    constructor(props, root) {
        this.isRoot = props.isRoot;
        this.rootNavigationId = props.rootNavigationId;
        this.dir = props.dir;
        this.orientation = props.orientation;
        this.value = props.value;
        this.onTriggerEnter = props.onTriggerEnter;
        this.onTriggerLeave = props.onTriggerLeave;
        this.onContentEnter = props.onContentEnter;
        this.onContentLeave = props.onContentLeave;
        this.onItemSelect = props.onItemSelect;
        this.onItemDismiss = props.onItemDismiss;
        this.root = root;
        this.previousValue = props.previousValue;
    }
    registerTrigger(ref) {
        this.triggerRefs.add(ref);
    }
    deRegisterTrigger(ref) {
        this.triggerRefs.delete(ref);
    }
    getTriggerNodes() {
        return Array.from(this.triggerRefs)
            .map((ref) => ref.current)
            .filter((node) => Boolean(node));
    }
}
class NavigationMenuSubState {
    id;
    isRoot = false;
    rootNavigationId;
    dir;
    orientation;
    value;
    previousValue = new Previous(() => this.value.current);
    onTriggerLeave;
    onContentEnter;
    onContentLeave;
    viewportNode = $state(null);
    indicatorTrackNode = $state(null);
    viewportContentId = box.with(() => undefined);
    root;
    triggerRefs = new Set();
    ref;
    constructor(props, root) {
        this.id = props.id;
        this.rootNavigationId = root.id;
        this.dir = root.dir;
        this.orientation = props.orientation;
        this.value = props.value;
        this.root = root;
        this.ref = props.ref;
        useRefById({
            id: this.id,
            ref: this.ref,
        });
    }
    onTriggerEnter(itemValue) {
        this.value.current = itemValue;
    }
    onItemSelect(itemValue) {
        this.value.current = itemValue;
    }
    registerTrigger(ref) {
        this.triggerRefs.add(ref);
    }
    deRegisterTrigger(ref) {
        this.triggerRefs.delete(ref);
    }
    getTriggerNodes() {
        return Array.from(this.triggerRefs)
            .map((ref) => ref.current)
            .filter((node) => Boolean(node));
    }
    props = $derived.by(() => ({
        id: this.id.current,
        "data-orientation": getDataOrientation(this.orientation.current),
        [NAVIGATION_MENU_SUB_ATTR]: "",
    }));
}
class NavigationMenuListState {
    menu;
    #id;
    #ref;
    indicatorTrackRef;
    indicatorTrackId = box(useId());
    rovingFocusGroup;
    constructor(props, menu) {
        this.menu = menu;
        this.#id = props.id;
        this.#ref = props.ref;
        this.indicatorTrackRef = props.indicatorTrackRef;
        this.rovingFocusGroup = useRovingFocus({
            rootNodeId: this.#id,
            candidateAttr: NAVIGATION_MENU_TRIGGER_ATTR,
            candidateSelector: `:is([${NAVIGATION_MENU_TRIGGER_ATTR}], [data-list-link]):not([data-disabled])`,
            loop: box.with(() => false),
            orientation: this.menu.orientation,
        });
        useRefById({
            id: this.#id,
            ref: this.#ref,
        });
        useRefById({
            id: this.indicatorTrackId,
            ref: this.indicatorTrackRef,
            onRefChange: (node) => {
                this.menu.indicatorTrackNode = node;
            },
            deps: () => Boolean(this.menu.root.value.current),
        });
    }
    indicatorTrackProps = $derived.by(() => ({
        id: this.indicatorTrackId.current,
        style: {
            position: "relative",
        },
    }));
    props = $derived.by(() => ({
        id: this.#id.current,
        "data-orientation": getDataOrientation(this.menu.orientation.current),
        [NAVIGATION_MENU_LIST_ATTR]: "",
    }));
}
class NavigationMenuItemState {
    id;
    #ref;
    value;
    contentNode = $state(null);
    triggerNode = $state(null);
    focusProxyRef = box(null);
    focusProxyNode = $state(null);
    focusProxyId = box(useId());
    restoreContentTabOrder = noop;
    wasEscapeClose = $state(false);
    menu;
    list;
    constructor(props, list, menu) {
        this.id = props.id;
        this.#ref = props.ref;
        this.value = props.value;
        this.menu = menu;
        this.list = list;
        this.handleContentEntry = this.handleContentEntry.bind(this);
        this.handleContentExit = this.handleContentExit.bind(this);
        useRefById({
            id: this.id,
            ref: this.#ref,
        });
    }
    handleContentEntry(side = "start") {
        if (!this.contentNode)
            return;
        this.restoreContentTabOrder();
        const candidates = getTabbableCandidates(this.contentNode);
        if (candidates.length) {
            if (side === "start") {
                candidates[0]?.focus();
            }
            else {
                candidates[candidates.length - 1]?.focus();
            }
        }
    }
    handleContentExit() {
        if (!this.contentNode)
            return;
        const candidates = getTabbableCandidates(this.contentNode);
        if (candidates.length) {
            this.restoreContentTabOrder = removeFromTabOrder(candidates);
        }
    }
    onEntryKeydown = this.handleContentEntry;
    onFocusProxyEnter = this.handleContentEntry;
    onContentFocusOutside = this.handleContentExit;
    onRootContentClose = this.handleContentExit;
    props = $derived.by(() => ({
        id: this.id.current,
        [NAVIGATION_MENU_ITEM_ATTR]: "",
    }));
}
class NavigationMenuTriggerState {
    #id;
    #ref;
    focusProxyMounted = $state(false);
    menu;
    item;
    disabled;
    hasPointerMoveOpened = boxAutoReset(false, 150);
    wasClickClose = $state(false);
    open = $derived.by(() => this.item.value.current === this.menu.value.current);
    constructor(props, item) {
        this.#id = props.id;
        this.#ref = props.ref;
        this.item = item;
        this.menu = item.menu;
        this.disabled = props.disabled;
        useRefById({
            id: this.#id,
            ref: this.#ref,
            onRefChange: (node) => {
                this.item.triggerNode = node;
            },
        });
        useRefById({
            id: this.item.focusProxyId,
            ref: this.item.focusProxyRef,
            onRefChange: (node) => {
                this.item.focusProxyNode = node;
            },
            deps: () => this.focusProxyMounted,
        });
        $effect(() => {
            this.menu.registerTrigger(this.#ref);
            return () => {
                this.menu.deRegisterTrigger(this.#ref);
            };
        });
        this.onpointerenter = this.onpointerenter.bind(this);
        this.onpointermove = this.onpointermove.bind(this);
        this.onpointerleave = this.onpointerleave.bind(this);
        this.onclick = this.onclick.bind(this);
        this.onkeydown = this.onkeydown.bind(this);
    }
    onpointerenter(_) {
        this.wasClickClose = false;
        this.item.wasEscapeClose = false;
    }
    onpointermove(e) {
        if (e.pointerType !== "mouse")
            return;
        if (this.disabled.current ||
            this.wasClickClose ||
            this.item.wasEscapeClose ||
            this.hasPointerMoveOpened.current)
            return;
        this.menu.onTriggerEnter(this.item.value.current);
        this.hasPointerMoveOpened.current = true;
    }
    onpointerleave(e) {
        if (e.pointerType !== "mouse" || this.disabled.current)
            return;
        this.menu.onTriggerLeave?.();
        this.hasPointerMoveOpened.current = false;
    }
    onclick(_) {
        // if opened via pointer move, we prevent clicked event
        if (this.hasPointerMoveOpened.current)
            return;
        if (this.open) {
            this.menu.onItemSelect("");
        }
        else {
            this.menu.onItemSelect(this.item.value.current);
        }
        this.wasClickClose = this.open;
    }
    onkeydown(e) {
        const verticalEntryKey = this.menu.dir.current === "rtl" ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT;
        const entryKey = {
            horizontal: kbd.ARROW_DOWN,
            vertical: verticalEntryKey,
        }[this.menu.orientation.current];
        if (this.open && e.key === entryKey) {
            this.item.onEntryKeydown();
            e.preventDefault();
            return;
        }
        this.item.list.rovingFocusGroup.handleKeydown(this.#ref.current, e);
    }
    props = $derived.by(() => ({
        id: this.#id.current,
        disabled: getDisabled(this.disabled.current),
        "data-disabled": getDataDisabled(this.disabled.current),
        "data-state": getDataOpenClosed(this.open),
        "aria-expanded": getAriaExpanded(this.open),
        "aria-controls": this.item.contentNode ? this.item.contentNode.id : undefined,
        "data-value": this.item.value.current,
        onpointerenter: this.onpointerenter,
        onpointermove: this.onpointermove,
        onpointerleave: this.onpointerleave,
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        [NAVIGATION_MENU_TRIGGER_ATTR]: "",
    }));
    visuallyHiddenProps = $derived.by(() => ({
        id: this.item.focusProxyId.current,
        "aria-hidden": "true",
        tabIndex: 0,
        onfocus: (e) => {
            const prevFocusedElement = e.relatedTarget;
            const wasTriggerFocused = prevFocusedElement === this.item.triggerNode;
            const wasFocusFromContent = this.item.contentNode?.contains(prevFocusedElement);
            if (wasTriggerFocused || !wasFocusFromContent) {
                e.preventDefault();
                this.item.onFocusProxyEnter(wasTriggerFocused ? "start" : "end");
            }
        },
    }));
}
class NavigationMenuLinkState {
    #id;
    #ref;
    active;
    onSelect;
    content;
    item;
    constructor(props, item, content) {
        this.#id = props.id;
        this.#ref = props.ref;
        this.active = props.active;
        this.onSelect = props.onSelect;
        this.content = content;
        this.item = item;
        useRefById({
            id: this.#id,
            ref: this.#ref,
        });
        this.onclick = this.onclick.bind(this);
        this.onkeydown = this.onkeydown.bind(this);
    }
    onclick(e) {
        const linkSelectEvent = new CustomEvent("navigationMenu.linkSelect", {
            bubbles: true,
            cancelable: true,
        });
        this.onSelect.current(linkSelectEvent);
        if (!linkSelectEvent.defaultPrevented && !e.metaKey) {
            //
        }
    }
    onkeydown(e) {
        this.item.list.rovingFocusGroup.handleKeydown(this.#ref.current, e);
    }
    props = $derived.by(() => ({
        id: this.#id.current,
        "data-active": this.active.current ? "" : undefined,
        "aria-current": this.active.current ? "page" : undefined,
        "data-list-link": this.content ? undefined : "",
        onclick: this.onclick,
        onfocus: (_) => { },
        onkeydown: this.content ? undefined : this.onkeydown,
    }));
}
class NavigationMenuIndicatorState {
    id;
    menu;
    activeTrigger = $state(null);
    position = $state(null);
    isHorizontal = $derived.by(() => this.menu.orientation.current === "horizontal");
    isVisible = $derived.by(() => Boolean(this.menu.value.current));
    indicatorRef;
    constructor(props, menu) {
        this.id = props.id;
        this.indicatorRef = props.ref;
        this.menu = menu;
        useRefById({
            id: this.id,
            ref: this.indicatorRef,
            onRefChange: (node) => {
                this.menu.viewportNode = node;
            },
        });
        $effect(() => {
            const triggerNodes = this.menu.getTriggerNodes();
            const triggerNode = triggerNodes.find((node) => node.dataset.value === this.menu.value.current);
            if (triggerNode) {
                untrack(() => {
                    this.activeTrigger = triggerNode;
                });
            }
        });
        useResizeObserver(() => this.activeTrigger, this.handlePositionChange);
        useResizeObserver(() => this.menu.indicatorTrackNode, this.handlePositionChange);
    }
    handlePositionChange = () => {
        if (!this.activeTrigger)
            return;
        this.position = {
            size: this.isHorizontal
                ? this.activeTrigger.offsetWidth
                : this.activeTrigger.offsetHeight,
            offset: this.isHorizontal
                ? this.activeTrigger.offsetLeft
                : this.activeTrigger.offsetTop,
        };
    };
    props = $derived.by(() => ({
        "aria-hidden": getAriaHidden(true),
        "data-state": this.isVisible ? "visible" : "hidden",
        "data-orientation": getDataOrientation(this.menu.orientation.current),
        style: {
            position: "absolute",
            ...(this.isHorizontal
                ? {
                    left: 0,
                    width: this.position ? `${this.position.size}px` : undefined,
                    transform: this.position
                        ? `translateX(${this.position.offset}px)`
                        : undefined,
                }
                : {
                    top: 0,
                    height: this.position ? `${this.position.size}px` : undefined,
                    transform: this.position
                        ? `translateY(${this.position.offset}px)`
                        : undefined,
                }),
        },
        [NAVIGATION_MENU_INDICATOR_ATTR]: "",
    }));
}
class NavigationMenuContentState {
    id;
    forceMount;
    isMounted;
    contentRef;
    menu;
    item;
    prevMotionAttribute = $state(null);
    motionAttribute = $state(null);
    open = $derived.by(() => this.menu.value.current === this.item.value.current);
    isPresent = $derived.by(() => this.open || this.forceMount.current);
    constructor(props, item) {
        this.id = props.id;
        this.forceMount = props.forceMount;
        this.isMounted = props.isMounted;
        this.item = item;
        this.menu = item.menu;
        this.contentRef = props.ref;
        useRefById({
            id: this.id,
            ref: this.contentRef,
            onRefChange: (node) => {
                this.item.contentNode = node;
            },
            deps: () => this.isMounted.current,
        });
        $effect(() => {
            const items = this.menu.getTriggerNodes();
            const prev = this.menu.previousValue.current;
            const values = items
                .map((item) => item.dataset.value)
                .filter((v) => Boolean(v));
            if (this.menu.dir.current === "rtl")
                values.reverse();
            const index = values.indexOf(this.menu.value.current);
            const prevIndex = values.indexOf(prev ?? "");
            const isSelected = this.item.value.current === this.menu.value.current;
            const wasSelected = prevIndex === values.indexOf(this.item.value.current);
            // We only want to update selected and the last selected content
            // this avoids animations being interrupted outside of that range
            if (!isSelected && !wasSelected) {
                this.motionAttribute = this.prevMotionAttribute;
            }
            const attribute = (() => {
                // Don't provide a direction on the initial open
                if (index !== prevIndex) {
                    // If we're moving to this item from another
                    if (isSelected && prevIndex !== -1) {
                        return index > prevIndex ? "from-end" : "from-start";
                    }
                    // If we're leaving this item for another
                    if (wasSelected && index !== -1) {
                        return index > prevIndex ? "to-start" : "to-end";
                    }
                }
                // Otherwise we're entering from closed or leaving the list
                // entirely and should not animate in any direction
                return null;
            })();
            this.prevMotionAttribute = attribute;
            this.motionAttribute = attribute;
        });
        this.onFocusOutside = this.onFocusOutside.bind(this);
        this.onInteractOutside = this.onInteractOutside.bind(this);
        this.onEscapeKeydown = this.onEscapeKeydown.bind(this);
        this.onkeydown = this.onkeydown.bind(this);
    }
    onFocusOutside(e) {
        this.item.onContentFocusOutside();
        const target = e.target;
        // only dismiss content when focus moves outside the menu
        if (this.menu.root.rootRef.current?.contains(target)) {
            e.preventDefault();
        }
        else {
            this.menu.root.handleClose();
        }
    }
    onInteractOutside(e) {
        if (e.defaultPrevented)
            return;
        const target = e.target;
        const isTrigger = this.menu.getTriggerNodes().some((node) => node.contains(target));
        const isRootViewport = this.menu.isRoot && this.menu.viewportNode?.contains(target);
        if (isTrigger || isRootViewport || !this.menu.isRoot) {
            e.preventDefault();
        }
    }
    onEscapeKeydown = (e) => {
        this.menu.root.handleClose();
        const target = e.target;
        if (this.contentRef.current?.contains(target)) {
            this.item.triggerNode?.focus();
        }
        this.item.wasEscapeClose = true;
    };
    onkeydown(e) {
        const isMetaKey = e.altKey || e.ctrlKey || e.metaKey;
        const isTabKey = e.key === kbd.TAB && !isMetaKey;
        const candidates = getTabbableCandidates(e.currentTarget);
        if (isTabKey) {
            const focusedElement = document.activeElement;
            const index = candidates.findIndex((candidate) => candidate === focusedElement);
            const isMovingBackwards = e.shiftKey;
            const nextCandidates = isMovingBackwards
                ? candidates.slice(0, index).reverse()
                : candidates.slice(index + 1, candidates.length);
            if (focusFirst(nextCandidates)) {
                // prevent browser tab keydown because we've handled focus
                e.preventDefault();
                return;
            }
            else {
                // If we can't focus that means we're at the edges
                // so focus the proxy and let browser handle
                // tab/shift+tab keypress on the proxy instead
                this.item.focusProxyNode?.focus();
                return;
            }
        }
        const newSelectedElement = useArrowNavigation(e, document.activeElement, undefined, {
            itemsArray: candidates,
            attributeName: `[${NAVIGATION_MENU_LINK_ATTR}]`,
            loop: false,
            enableIgnoredElement: true,
        });
        newSelectedElement?.focus();
    }
    props = $derived.by(() => ({
        id: this.id.current,
        "aria-labelledby": this.item.triggerNode?.id ?? undefined,
        "data-motion": this.motionAttribute,
        "data-state": getDataOpenClosed(this.menu.value.current === this.item.value.current),
        "data-orientation": getDataOrientation(this.menu.orientation.current),
        [NAVIGATION_MENU_CONTENT_ATTR]: "",
        style: {
            pointerEvents: !this.open && this.menu.isRoot ? "none" : undefined,
        },
        onkeydown: this.onkeydown,
    }));
}
class NavigationMenuViewportState {
    id;
    menu;
    size = $state(null);
    open = $derived.by(() => this.menu.value.current !== "");
    activeContentValue = $derived.by(() => this.menu.value.current);
    viewportRef;
    contentNode = $state();
    constructor(props, menu) {
        this.id = props.id;
        this.menu = menu;
        this.viewportRef = props.ref;
        useRefById({
            id: this.id,
            ref: this.viewportRef,
            onRefChange: (node) => {
                this.menu.viewportNode = node;
            },
            deps: () => this.open,
        });
        $effect(() => {
            this.open;
            this.activeContentValue;
            const currentNode = untrack(() => this.viewportRef.current);
            if (!currentNode)
                return;
            afterTick(() => {
                const contentNode = currentNode.querySelector("[data-state=open]")
                    ?.children?.[0];
                this.contentNode = contentNode;
            });
        });
        useResizeObserver(() => this.contentNode, () => {
            if (this.contentNode) {
                this.size = {
                    width: this.contentNode.offsetWidth,
                    height: this.contentNode.offsetHeight,
                };
            }
        });
        this.onpointerenter = this.onpointerenter.bind(this);
        this.onpointerleave = this.onpointerleave.bind(this);
    }
    onpointerenter(_) {
        this.menu.onContentEnter?.();
    }
    onpointerleave(e) {
        if (e.pointerType !== "mouse")
            return;
        this.menu.onContentLeave?.();
    }
    props = $derived.by(() => ({
        id: this.id.current,
        "data-state": getDataOpenClosed(this.open),
        "data-orientation": getDataOrientation(this.menu.orientation.current),
        style: {
            pointerEvents: !this.open && this.menu.isRoot ? "none" : undefined,
            "--bits-navigation-menu-viewport-width": this.size
                ? `${this.size.width}px`
                : undefined,
            "--bits-navigation-menu-viewport-height": this.size
                ? `${this.size.height}px`
                : undefined,
        },
        onpointerenter: this.onpointerenter,
        onpointerleave: this.onpointerleave,
    }));
}
export function useNavigationMenuRoot(props) {
    const rootState = new NavigationMenuRootState(props);
    const menuState = new NavigationMenuMenuState({
        rootNavigationId: rootState.id,
        dir: rootState.dir,
        orientation: rootState.orientation,
        value: rootState.value,
        isRoot: true,
        onTriggerEnter: rootState.onTriggerEnter,
        onItemSelect: rootState.onItemSelect,
        onItemDismiss: rootState.onItemDismiss,
        onContentEnter: rootState.onContentEnter,
        onContentLeave: rootState.onContentLeave,
        onTriggerLeave: rootState.onTriggerLeave,
        previousValue: rootState.previousValue,
    }, rootState);
    NavigationMenuMenuContext.set(menuState);
    return NavigationMenuRootContext.set(rootState);
}
export function useNavigationMenuList(props) {
    return NavigationMenuListContext.set(new NavigationMenuListState(props, NavigationMenuMenuContext.get()));
}
export function useNavigationMenuItem(props) {
    const listState = NavigationMenuListContext.get();
    return NavigationMenuItemContext.set(new NavigationMenuItemState(props, listState, listState.menu));
}
export function useNavigationMenuTrigger(props) {
    return new NavigationMenuTriggerState(props, NavigationMenuItemContext.get());
}
export function useNavigationMenuContent(props) {
    return NavigationMenuContentContext.set(new NavigationMenuContentState(props, NavigationMenuItemContext.get()));
}
export function useNavigationMenuViewport(props) {
    return new NavigationMenuViewportState(props, NavigationMenuMenuContext.get());
}
export function useNavigationMenuIndicator(props) {
    return new NavigationMenuIndicatorState(props, NavigationMenuMenuContext.get());
}
export function useNavigationMenuLink(props) {
    const content = NavigationMenuContentContext.getOr(null);
    if (content) {
        return new NavigationMenuLinkState(props, content.item, content);
    }
    return new NavigationMenuLinkState(props, NavigationMenuItemContext.get());
}
/// Utils
function focusFirst(candidates) {
    const previouslyFocusedElement = document.activeElement;
    return candidates.some((candidate) => {
        // if focus is already where we want to go, we don't want to keep going through the candidates
        if (candidate === previouslyFocusedElement)
            return true;
        candidate.focus();
        return document.activeElement !== previouslyFocusedElement;
    });
}
function removeFromTabOrder(candidates) {
    candidates.forEach((candidate) => {
        candidate.dataset.tabindex = candidate.getAttribute("tabindex") || "";
        candidate.setAttribute("tabindex", "-1");
    });
    return () => {
        candidates.forEach((candidate) => {
            const prevTabIndex = candidate.dataset.tabindex;
            candidate.setAttribute("tabindex", prevTabIndex);
        });
    };
}
function useResizeObserver(element, onResize) {
    $effect(() => {
        let rAF = 0;
        const node = element();
        if (node) {
            const resizeObserver = new ResizeObserver(() => {
                cancelAnimationFrame(rAF);
                rAF = window.requestAnimationFrame(onResize);
            });
            resizeObserver.observe(node);
            return () => {
                window.cancelAnimationFrame(rAF);
                resizeObserver.unobserve(node);
            };
        }
    });
}
